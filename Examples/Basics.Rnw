\section{Basics}
\label{sec:basics}

The \texttt{caret} package is one that can take of parallel execution. Below, I train a random forest on a sample dataset~\cite{lichman2013}.

% This chunk depends on the MD5 of chess.txt; if that file changes, the chunk needs to be updated
<<basics-data, cache.md5 = my_md5sum("Data/chess.txt")>>=

# Notice how the path on the chunk options above is with respect to root file Thesis.Rnw
# However, the actual chunk code below needs a path with respect to the current file
chess <- read.csv("../Data/chess.txt", header = FALSE)
colnames(chess)[ncol(chess)] <- "label"

@

<<chess-rf, echo = TRUE>>=
set.seed(3830)

chess_rf <- train(label ~ ., data = chess,
                  method = "rf",
                  tuneGrid = data.frame(mtry = 8:15),
                  trControl = trainControl(method = "oob"))

best <- chess_rf$bestTune$mtry
acc <- round(chess_rf$results$Accuracy[chess_rf$results$mtry == best],
             3)
@

Using a random forest with the Chess dataset and OOB error estimate, best value of \texttt{mtry} was \Sexpr{best} with an accuracy of \Sexpr{acc}.

Try changing the seed (to invalidate the chunk's cache) and compiling the thesis with/without parallel support to see the difference in run time.

If you don't specify a seed, you might lose reproducibility. For example, the code below might give a different result each time you recompile if you add code before it and \textit{after} the cache for the previous chunk has been created. This is because the previous chunk will no longer set the seed unless its cache is invalidated and the chunk is thus updated.

<<randomness, cache = FALSE, echo = TRUE, load.utils = NULL>>=
rnorm(1)
@

<<basics-clean, include = FALSE, cache = FALSE, load.utils = NULL, dependson = NULL>>=

# If there are parallel workers saved on a variable called 'cl' (the default), clean each worker too
if (!is.null(cl <- get0("cl", .GlobalEnv))) parallel::clusterEvalQ(cl, clean_workspace(load.utils = TRUE))

# Clean knitr environment so that each child file is independent from each other
clean_workspace()

@
